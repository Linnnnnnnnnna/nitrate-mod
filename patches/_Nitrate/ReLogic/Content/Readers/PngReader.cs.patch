--- src/tModLoader/ReLogic/Content/Readers/PngReader.cs
+++ src/Nitrate/ReLogic/Content/Readers/PngReader.cs
@@ -19,45 +_,27 @@
 		_graphicsDevice = graphicsDevice;
 		_colorProcessingCache = new ThreadLocal<Color[]>();
 	}
-	
-	// Implemented by TML.
-	public Type[] GetAssociatedTypes() => new[] { typeof(Texture2D) };
 
-	/*
-	public T FromStream<T>(Stream stream) where T : class
-	*/
+	// TML: Implement modified asynchronous signature.
 	public async ValueTask<T> FromStream<T>(Stream stream, MainThreadCreationContext mainThreadCtx) where T : class
 	{
-		if (typeof(T) != typeof(Texture2D))
-			throw AssetLoadException.FromInvalidReader<PngReader, T>();
+		Contracts.AssertValidReaderForAssetType<PngReader, Texture2D, T>();
 
-#if NETCORE
-		IntPtr img = FNA3D.ReadImageStream(stream, out int width, out int height, out int len);
+		nint img = FNA3D.ReadImageStream(stream, out int width, out int height, out int len);
 		PreMultiplyAlpha(img, len);
 
+		// BEGIN TML: await main threat context and assert completion.
+		{
-		await mainThreadCtx;
+			await mainThreadCtx;
-		Debug.Assert(mainThreadCtx.IsCompleted);
+			Debug.Assert(mainThreadCtx.IsCompleted);
+		}
+		// END TML
 
 		var texture2D = new Texture2D(_graphicsDevice, width, height);
 		texture2D.SetDataPointerEXT(0, null, img, len);
 		FNA3D.FNA3D_Image_Free(img);
 
 		return texture2D as T;
-#else
-		Texture2D texture2D = Texture2D.FromStream(_graphicsDevice, stream);
-		int num = texture2D.Width * texture2D.Height;
-		if (!_colorProcessingCache.IsValueCreated || _colorProcessingCache.Value.Length < num)
-			_colorProcessingCache.Value = new Color[num];
-
-		Color[] value = _colorProcessingCache.Value;
-		texture2D.GetData(value, 0, num);
-		for (int i = 0; i != num; i++) {
-			value[i] = Color.FromNonPremultiplied(value[i].ToVector4());
-		}
-
-		texture2D.SetData(value, 0, num);
-		return texture2D as T;
-#endif
 	}
 
 	protected virtual void Dispose(bool disposing)
@@ -75,7 +_,6 @@
 		Dispose(disposing: true);
 	}
 
-#if NETCORE
 	private static unsafe void PreMultiplyAlpha(IntPtr img, int len)
 	{
 		byte* colors = (byte*)img.ToPointer();
@@ -85,7 +_,6 @@
 			colors[i] = (byte)(colors[i] * a / byte.MaxValue);
 			colors[i + 1] = (byte)(colors[i + 1] * a / byte.MaxValue);
 			colors[i + 2] = (byte)(colors[i + 2] * a / byte.MaxValue);
- 		}
- 	}
-#endif
+		}
+	}
 }
